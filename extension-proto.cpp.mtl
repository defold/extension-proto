#define EXTENSION_NAME Proto
#define LIB_NAME "Proto"
#define MODULE_NAME "proto"

#define DLIB_LOG_DOMAIN LIB_NAME
#include <dmsdk/sdk.h>
#include <stdlib.h>


{{#files}}
#include "{{filename_h}}"
{{/files}}



/******************************************************************************
 * PUSH
 ******************************************************************************/

{{#messages}}
static void lua_push{{type_cpp_lower}}(lua_State* L, {{type_cpp}} *msg);
{{/messages}}

{{#messages}}
static void lua_push{{type_cpp_lower}}(lua_State* L, {{type_cpp}} *msg)
{
    lua_newtable(L);

    {{#properties}}
    {{#repeated}}
    // {{name}}
    lua_pushstring(L, "{{name}}");
    lua_newtable(L);
    int {{name}}_size = msg->n_{{name}};
    for (int i = 0; i < {{name}}_size; i++)
    {
        lua_pushnumber(L, i + 1);
        lua_push{{type_lua}}(L, ({{type_cpp}})msg->{{name}}[i]);
        lua_settable(L, -3);
    }
    lua_settable(L, -3);

    {{/repeated}}
    {{^repeated}}
    // {{name}}
    lua_pushstring(L, "{{name}}");
    lua_push{{type_lua}}(L, ({{type_cpp}})msg->{{name}});
    lua_settable(L, -3);

    {{/repeated}}
    {{/properties}}
}
{{/messages}}


/******************************************************************************
 * CHECK 
 ******************************************************************************/

static int luaL_checkboolean(lua_State* L, int narg) { return lua_toboolean(L, narg); }

{{#messages}}
static {{type_cpp}}* luaL_check{{type_cpp_lower}}(lua_State* L, int narg);
{{/messages}}

{{#messages}}
static {{type_cpp}}* luaL_check{{type_cpp_lower}}(lua_State* L, int narg)
{
    if (!lua_istable(L, narg)) {
        luaL_error(L, "Expected value at index %d to be a table", narg);
        return 0;
    }

    {{type_cpp}} *msg = ({{type_cpp}}*)malloc(sizeof({{type_cpp}}));
    {{type_cpp_lower}}__init(msg);

    {{#properties}}
    {{#repeated}}
    // {{name}}
    lua_pushstring(L, "{{name}}");
    lua_gettable(L, narg);
    int {{name}}_size = lua_objlen(L, lua_gettop(L));
    int {{name}}_index = lua_gettop(L);
    msg->n_{{name}} = {{name}}_size;
    msg->{{name}} = ({{type_cpp}}*)malloc(sizeof({{type_cpp}}) * {{name}}_size);
    for (int i = 0; i < {{name}}_size; i++)
    {
        lua_pushnumber(L, i + 1);
        lua_gettable(L, {{name}}_index);
        msg->{{name}}[i] = ({{type_cpp}})luaL_check{{type_lua}}(L, lua_gettop(L));
        lua_pop(L, 1);
    }
    lua_pop(L, 1);

    {{/repeated}}
    {{^repeated}}
    // {{name}}
    lua_pushstring(L, "{{name}}");
    lua_gettable(L, narg);
    msg->{{name}} = ({{type_cpp}})luaL_check{{type_lua}}(L, lua_gettop(L));
    lua_pop(L, 1);

    {{/repeated}}
    {{/properties}}
    return msg;
}
{{/messages}}



/******************************************************************************
 * FREE 
 ******************************************************************************/

{{#messages}}
static void free_{{type_cpp_lower}}({{type_cpp}}* msg);
{{/messages}}

static void free_number(int32_t) {};
static void free_string(char*) {};
static void free_bool(bool) {};
static void free_boolean(bool) {};

{{#messages}}
static void free_{{type_cpp_lower}}({{type_cpp}}* msg)
{
    {{#properties}}
    {{#repeated}}
    int {{name}}_size = msg->n_{{name}};
    for (int i = 0; i < {{name}}_size; i++)
    {
        free_{{type_lua}}(msg->{{name}}[i]);
    }
    free(msg->{{name}});
    {{/repeated}}
    {{^repeated}}
    free_{{type_lua}}(msg->{{name}});
    {{/repeated}}
    {{/properties}}
    free(msg);
}
{{/messages}}



/******************************************************************************
 * ENCODE AND DECODE
 ******************************************************************************/

{{#messages}}
{{^google}}
static int Decode{{name}}(lua_State* L)
{
    DM_LUA_STACK_CHECK(L, 1);
    size_t data_length;
    const char* data = luaL_checklstring(L, 1, &data_length);

    {{name}} *msg = {{name_lower}}__unpack(0, data_length, (uint8_t*)data);
    lua_push{{name_lower}}(L, msg);
    {{name_lower}}__free_unpacked(msg, 0);

    return 1;
}

static int Encode{{name}}(lua_State* L)
{
    DM_LUA_STACK_CHECK(L, 1);
    {{name}} *msg = luaL_check{{name_lower}}(L, 1);

    size_t {{name_lower}}_packed_size = {{name_lower}}__get_packed_size(msg);
    char* buffer = (char*)malloc({{name_lower}}_packed_size);
    {{name_lower}}__pack(msg, (uint8_t*)buffer);

    lua_pushlstring(L, buffer, {{name_lower}}_packed_size);
    free(buffer);

    free_{{name_lower}}(msg);

    return 1;
}
{{/google}}
{{/messages}}

static const luaL_reg Module_methods[] =
{
    {{#messages}}
    {{^google}}
    {"encode_{{name_lower}}", Encode{{name}} },
    {"decode_{{name_lower}}", Decode{{name}} },
    {{/google}}
    {{/messages}}
    {0,0}
};

static void LuaInit(lua_State* L)
{
    DM_LUA_STACK_CHECK(L, 0);
    int top = lua_gettop(L);
    luaL_register(L, MODULE_NAME, Module_methods);

    #define SETCONSTANT(name, val) \
    lua_pushnumber(L, (lua_Number) val); \
    lua_setfield(L, -2, #name);

    {{#enums}}
    // {{name}}
    {{#values}}
    SETCONSTANT({{name_upper}}_{{name}}, {{value}});
    {{/values}}
    {{/enums}}
    #undef SETCONSTANT

    lua_pop(L, 1);
}

static dmExtension::Result InitializeProto(dmExtension::Params* params)
{
    LuaInit(params->m_L);
    return dmExtension::RESULT_OK;
}

static dmExtension::Result FinalizProto(dmExtension::Params* params)
{
    return dmExtension::RESULT_OK;
}

DM_DECLARE_EXTENSION(EXTENSION_NAME, LIB_NAME, 0, 0, InitializeProto, 0, 0, FinalizProto)
